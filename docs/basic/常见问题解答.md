# 常见问题解答

## 返回时间格式
可以在`apllication.property`( `yml`格式请自行切换)加入下面配置就可以 
```
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8
```
如果是针对特定属性定制可以使用如下注解
```
@JsonFormat(timezone = "GMT+8", pattern = "yyyyMMddHHmmss")
private Date createDate;
```

## 如何进行组合查询
> 只要继承`ExtendedQueryDslJpaRepository`接口既可以使用如下语法进行组合查询操作

```
 public List<BlogOutputDto> fetchBlogs(SearchBlogsInputDto input) {
        var predicate = new BooleanBuilder();
        if(StringUtils.isNotEmpty(input.getUrl())) {
            predicate.and(QBlog.blog.url.contains(input.getUrl()));
        }
        if(StringUtils.isNotEmpty(input.getTitle())) {
            predicate.and(QBlog.blog.title.contains(input.getTitle()));
        }
        List<Blog> blogs = blogRepository.findAll(predicate);
        var res = Mapper.init().map(blogs,new GenericsToken<List<BlogOutputDto>>(){});
        return res;
}
```

## 无外键关联的两张表进行联合查询
```
List<FieldOutputDto> result = dataStructureRepository.query(
               query -> query.select(
                    Projections.constructor(FieldOutputDto.class,
                        dataStructure.stbm,
                        dataStructure.zdywmc,
                        dataStructure.sjybm,
                        dataSource.sjymc
                    )
                )
               .from(dataStructure)
               .leftJoin(dataSource).on(dataStructure.sjybm.eq(dataSource.sjybm))
               .fetch()
       );
      return result;
```
-  利用Projections.constructor实现此查询操作，FieldOutputDto中必须要有与选择列表相同的有参构造方法。

## 调用存储过程
```
方法一：
 var query = this.entityManager.createStoredProcedureQuery("pkg_ysj_sjy.PROC_GET_FLDM")
                .registerStoredProcedureParameter(1,String.class,ParameterMode.IN).setParameter(1,lbbm)
                .registerStoredProcedureParameter(2,Class.class, ParameterMode.REF_CURSOR)
                .registerStoredProcedureParameter(3,String.class,ParameterMode.OUT);
        List<ProcedureOutputDto> out = query.getResultList();
        return out;
        
方法二：
var session = this.entityManager.unwrap(Session.class);
        var call = session.createStoredProcedureCall("pkg_ysj_sjy.proc_get_fldm");
        call.registerParameter(1,String.class,ParameterMode.IN).bindValue(lbbm);
        call.registerParameter(2,Class.class,ParameterMode.REF_CURSOR);
        call.registerParameter(3,String.class,ParameterMode.OUT);
        var current = call.getOutputs().getCurrent();
        var out =  ((ResultSetOutput)current).getResultList();
        return out;
        
注：lbbm 为传入的参数
```
##### 动态调用存储过程
通过原生sql动态获取存储过程的输入参数个数。返回值为Object集合。通过遍历Object集合，循环为Query对象添加参数。
```
@Query(value = "SELECT argument_name,in_out FROM (\n" +
            " SELECT object_name,argument_name,in_out \n" +
            " FROM all_arguments \n" +
            " WHERE object_id= (\n" +
            " SELECT p.object_id\n" +
            " FROM SYS.ALL_OBJECTS a, SYS.ALL_PROCEDURES p\n" +
            " WHERE a.OBJECT_NAME = p.OBJECT_NAME AND a.OBJECT_TYPE = 'PACKAGE' \n" +
            " AND a.object_name = upper (trim (:packageName)) \n" +
            " AND a.OWNER = 'TYYW' AND p.PROCEDURE_NAME = upper(trim(:procedureName))) AND in_out = 'IN'\n" +
            ") WHERE object_name = upper(trim(:procedureName))",nativeQuery = true)
    List<Object[]> getProcedureParam(@Param("packageName") String packageName,@Param("procedureName") String procedureName);
```





## oracle驱动配置
> 配置 driver-class-name: oracle.jdbc.driver.OracleDriver     
会抛出警告：Registered driver with driverClassName=oracle.jdbc.driver.OracleDriver was not found, trying direct instantiation.      
将oracle.jdbc.driver.OracleDriver修改为oracle.jdbc.OracleDriver，即可。

!> 查询语句中，选择列表所包含的列的个数和列的顺序要与接收对象对应的类中的带参构造函数的参数列表相同。否则键和值不对应。