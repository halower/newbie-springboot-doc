# 5分钟快速上手

## 创建项目
创建一个空的`MAVEN` / `Gradle` 项目，结构如下

```
─src
    ├─main
    │  ├─java
    │  │  └─com
    │  │      └─demo    
    │  │          ├─controllers
    │  │          ├─domains
    │  │          ├─repositorys
    │  │          └─services
    │  │              └─blogs
    │  │                  └─dtos
    │  └─resources
    └─test


```

这个示例以`h2`数据库作为演示，以比较经典的简单博客模型作为基础，同时使用`gradle`构建，使用如下代码替换`build.gradle `

```build.gradle
group 'your's group'
version '1.0-SNAPSHOT'

buildscript {
    ext.springBootVersion= '2.0.5.RELEASE'

    repositories {
        maven { url 'http://192.168.2.23:8081/repository/maven-public/'}
    }

    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
    }
}

apply plugin: 'java'
apply plugin: 'org.springframework.boot'
apply plugin: 'io.spring.dependency-management'
sourceCompatibility = 1.8

repositories {
    maven { url 'http://192.168.2.23:8081/repository/maven-public/'}
}

dependencies {
    runtime 'com.h2database:h2'
    compile 'com.github.halower:newbie-spring-boot-starter: 2.5.0.1'
}

```

在 `resources` 中添加 `application.yml`

```application.yml
# 在线文档
swagger:
  title: 演示文档
  description: 进行非查询操作请在 header 添加 USER-ID 参数
  version: 1.0.0.RELEASE
  contact:
    name: 维护人/团队
    url: 维护人URL
    email: 维护人email
  base-path: /api/**
  exclude-path: /error
spring:
  application:
    name: newbie
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    database-platform: org.hibernate.dialect.H2Dialect
  datasource:
    url: jdbc:h2:file:d:/db
    username: sa
    password: sa
    driver-class-name: org.h2.Driver
  flyway:
    enabled: false #这个在演示示例中很重要
  data:
    rest:
      base-path: api
# 缓存方式
  cache:
    type: none
server:
  port: 8080
logging:
  level:
    root: info

```
**编写main函数**

``` 程序入口代码
@EnableNewBieApplication
public class BlogApplication {
    public static void main(String[] args) {
        SpringApplication.run(BlogApplication.class,args);
    }
}
```

## 建立模型
?> 在`domains`下创建以下模型，博客与文章是*一对多*关系
```Blog

@Data
@Entity
public class Blog extends FullAudited {
    @Id
    @GenericGenerator(name = "system-uuid", strategy = "uuid")
    @GeneratedValue(generator = "system-uuid")
    private int blogId;
    @Column(name = "url", nullable = false, length = 150)
    private String url;
    private int rating ;
    @OneToMany(mappedBy ="blog",cascade=CascadeType.ALL,fetch=FetchType.LAZY)
    private List<Post> posts ;
}
```

```Post
@Data
@Entity
public class Post extends FullAudited {
    @Id
    @GenericGenerator(name = "system-uuid", strategy = "uuid")
    @GeneratedValue(generator = "system-uuid")
    private int postId ;
    @Column(nullable = false, length = 50)
    private String title;
    @Column(nullable = false)
    private String content;
    @ManyToOne(cascade={CascadeType.MERGE,CascadeType.REFRESH},optional=false)
    @JoinColumn(name="blog_id")
    private Blog blog ;
}
```
自动生成的数据结构如下  
![](_img/db.png)

## 添加仓储接口
?> 在 `repositorys`下创建`BolgRepository`接口
```
public interface BlogRepository extends CrudRepository<Blog,Integer> {
}
```
## 添加服务接口
- 新增两个传输对象
```
@ApiModel("新增博客Dto")
@AllArgsConstructor
@Data
public class BlogInputDto implements InputDto<Blog> {
    @ApiModelProperty("博客链接")
    public String url;
}
```

```
@ApiModel("Blog输出参数")
@Data
@AllArgsConstructor
public class BlogOutputDto implements OutputDto {
    @ApiModelProperty("博客Id")
    public int blogId;
    @ApiModelProperty("博客鏈接")
    public String Url;
}

```

- 定义服务接口和实现类

```BlogAppService
public interface BlogAppService extends AppService {
    List<BlogOutputDto> fetchBlogs();
    int add(BlogInputDto input);
}
```

```BlogAppServiceImpl
@Service
@Transactional
public class BlogAppServiceImpl implements BlogAppService {
    @Autowired
     private BlogRepository blogRepository;
    @Override
    public List<BlogOutputDto> fetchBlogs() {
        var blogs = blogRepository.findAll();
        var res = Mapper.instance().map(blogs,new GenericsToken< List<BlogOutputDto>>() {});
        return res;
    }

    @Override
    public int add(BlogInputDto input) {
        var blog = input.map(Blog.class);
        var dbBlog = blogRepository.save(blog);
        return dbBlog.blogId;
    }
}


```
## 添加控制器

```
@RestController
@RequestMapping("/api/v1.0/blogs")
public class BlogController {
    @Autowired
    private BlogAppService blogAppService;

    @GetMapping("/")
    @ApiOperation("获取所有博客")
    @ResponseBody
    public ResponseResult<List<BlogOutputDto>> blogs() {
        var blogs = blogAppService.fetchBlogs();
       return  new ResponseResult<>(ResponseTypes.OK,blogs);
    }

    @PostMapping("/")
    @ApiOperation("添加博客")
    @ResponseBody
    public ResponseResult<Integer> add(@RequestBody BlogInputDto input) {
        var blogId = blogAppService.add(input);
        return  new ResponseResult<>(ResponseTypes.OK,blogId);
    }
}

```
> 现在就可以运行项目转到 <kbd>http://127.0.0.1:8080/swagger-ui.html</kbd> 
![](_img/demo.jpg)

## 如何迁移到Oracle
- 替换驱动包
`compile group: 'com.oracle', name: 'ojdbc6', version: '11.2.0.3'`

- 修改配置
```
    database-platform: org.hibernate.dialect.OracleDialect
  datasource:
    url: jdbc:oracle:xxx:@xxx.xxx.xxx.xxx:1521/xxx
    username: xxxx
    password: xxxx
    driver-class-name: oracle.jdbc.driver.OracleDriver
```