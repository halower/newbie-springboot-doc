# 流畅API操作数据

?> `SBLIE`在 `spring-data-jpa`的基础之上做了一些扩展，你可以使用`JPA`的所有功能接口，同时支持`QueryDsl`的所有功能。


## QueryDsl扩展
针对`QueryDsl` 支持所有的默认实现方法,也就是说你可以构建`QueryFactory`进行原始处理，同时提供了`ExtendedQueryDslJpaRepository` (注意不是默认内置的 `QueryDslJpaRepository`)接口，此接口是事务安全的，不需要你手动处理。你在使用的基于此接口实现你的业务接口例如:

!> 注意对于maven项目中无法生成`Q class`，解决方案如下：额外添加两个依赖和一个`build插件`即可
```
   <!--queryDSL-->
        <dependency>
            <groupId>com.querydsl</groupId>
            <artifactId>querydsl-jpa</artifactId>

        </dependency>
        <dependency>
            <groupId>com.querydsl</groupId>
            <artifactId>querydsl-apt</artifactId>
            <scope>provided</scope>
        </dependency>

        <build>
        <plugins>
            <!--该插件可以生成querysdl需要的查询对象，执行mvn compile即可-->
            <plugin>
                <groupId>com.mysema.maven</groupId>
                <artifactId>apt-maven-plugin</artifactId>
                <version>1.1.3</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>process</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>target/generated-sources/java</outputDirectory>
                            <processor>com.querydsl.apt.jpa.JPAAnnotationProcessor</processor>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

```

!> Gradle 额外自动生成配置
```
apply plugin: 'idea'

idea {
	module {
		sourceDirs += file('src/main/generated')
		testSourceDirs+=file('src/test/generated')
	}
}

compileJava {
	file('/src/main/generated').mkdirs()
	options.compilerArgs << '-processor' << 'com.querydsl.apt.jpa.JPAAnnotationProcessor' << '-s' << file('src/main/generated').absolutePath
}

clean{
	delete '/src/main/generated'
	delete '/src/test/generated'
}
```


### 基础查询
```
var blogs = blogRepository
.query(q->
q.select(blog).
from(blog)
.where(blog.blogId.lt(100))
.fetch());
```
### 排序
```
var blogs = blogRepository.query(q->
    q.select(blog)
    .from(blog)
    .orderBy(
        blog.blogId.asc(),
        blog.url.desc())
    .fetch());
```
### 子查询
```
     var blogs = blogRepository.query(q ->
        q.select(blog)
        .from(blog)
        .where(blog.posts.size().eq(
        JPAExpressions
                .select(blog.posts.size().max())
                .from(blog)
        ))
        .fetch());
```
### 数据投射
> 即部分字段查询 `BlogOnlyUrlOutputDto` 只包含了`url`属性
```
    var  blogs = blogRepository.query(q ->
    q.select(Projections.constructor(BlogOnlyUrlOutputDto.class,blog.url))
    .from(blog)
    .fetch());
    // 等同于，不过下面的返回的是字符串集合
    blogRepository.query(query -> query.select(blog.url).from(blog).fetch())
```
### 批量更新
```
    blogRepository.update(query -> query
        .set(person.url, "www.baidu.com")
        .where(blog.blogId.gt(20))
        .execute());
```
### 批量删除
```
repository.deleteWhere(blog.url.like("%baidu%"))
```
### `union`查询
```
blogRepository.jpaSqlQuery(query -> query
        .union(
        blogRepository.jpaSqlSubQuery(subQuery ->
            subQuery.select(blog)
               .from(blog)
               .where(blog.url.like("%baidu%"))),
        blogRepository.jpaSqlSubQuery(subQuery ->
            subQuery.select(blog)
                .from(blog)
                .where(blog.url.like("suhu%")))
        )
        .orderBy(blog.blogId.desc(), person.url.asc())
        .fetch()
);
```

### 存储过程支持
!> 为了业务代码的维护和扩展迁移等因素，不是非常建议使用存储过程,当然这一切还是要从实际需求的角度去做决定
```
 blogRepository.executeStoredProcedure(
            "Fetch_BlogGt5",
            builder -> builder.addInParameter(blog.blogId, input.getId()).getResultList());
```

### 扩展阅读
- [Querydsl 文档](http://www.querydsl.com/static/querydsl/latest/reference/html_single/)


